name: 'üè∑Ô∏è Issue Triage'

on:
  issues:
    types:
      - 'opened'
      - 'reopened'
  issue_comment:
    types:
      - 'created'
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to triage'
        required: true
        type: 'number'

concurrency:
  group: '${{ github.workflow }}-${{ github.event.issue.number || github.event.inputs.issue_number }}'
  cancel-in-progress: true

permissions:
  contents: 'read'
  issues: 'write'

jobs:
  triage-issue:
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'issues' ||
      (
        github.event_name == 'issue_comment' &&
        contains(github.event.comment.body, '/triage') &&
        (
          github.event.comment.author_association == 'OWNER' ||
          github.event.comment.author_association == 'MEMBER' ||
          github.event.comment.author_association == 'COLLABORATOR'
        )
      )
    timeout-minutes: 20
    runs-on: 'ubuntu-latest'

    steps:
      - name: 'Check if already triaged'
        id: 'check_labels'
        if: github.event_name != 'workflow_dispatch'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const labels = context.payload.issue?.labels?.map(l => l.name) || [];
            const triageLabels = ['bug', 'enhancement', 'documentation', 'question', 'invalid'];
            const areaLabels = labels.filter(l => l.startsWith('area/'));
            const hasTriageLabel = labels.some(l => triageLabels.includes(l)) || areaLabels.length > 0;
            const isRetriage = context.payload.comment?.body?.includes('/triage');
            
            if (hasTriageLabel && !isRetriage) {
              core.info(`Issue already triaged: ${labels.join(', ')}. Skipping.`);
              core.setOutput('skip', 'true');
            } else {
              core.setOutput('skip', 'false');
            }

      - name: 'Get issue data'
        id: 'get_issue'
        if: steps.check_labels.outputs.skip != 'true'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const issueNumber = context.payload.inputs?.issue_number || context.issue?.number;
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNumber),
            });
            core.setOutput('number', issue.number);
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');

      - name: 'Get open issues for duplicate detection'
        id: 'get_issues'
        if: steps.check_labels.outputs.skip != 'true'
        uses: 'actions/github-script@v7'
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 50,
              sort: 'updated',
              direction: 'desc'
            });
            
            const currentIssueNumber = parseInt('${{ steps.get_issue.outputs.number }}');
            const otherIssues = issues
              .filter(i => i.number !== currentIssueNumber && !i.pull_request)
              .map(i => `#${i.number}: ${i.title}`)
              .slice(0, 30)
              .join('\n');
            
            core.setOutput('list', otherIssues);

      - name: 'Build triage prompt'
        id: 'build_prompt'
        if: steps.check_labels.outputs.skip != 'true'
        run: |
          cat << 'EOF' > triage_prompt.txt
          ## Role
          You are an expert triage assistant AND a master user of opencode-antigravity-auth.
          You know this plugin inside-out: the README, architecture, common issues, and troubleshooting steps.
          You are extremely helpful and want to solve users problems quickly.
          
          **IMPORTANT: Always respond in English, regardless of the language of the issue.**
          
          This is an OpenCode plugin that enables OAuth authentication with Googles Antigravity API to access models like Claude Opus 4.5, Claude Sonnet 4.5, and Gemini 3 Pro.

          ## Current Issue to Triage
          Title: ${{ steps.get_issue.outputs.title }}
          Body: ${{ steps.get_issue.outputs.body }}

          ## Other Open Issues (check for duplicates)
          ${{ steps.get_issues.outputs.list }}

          ## Your Deep Knowledge

          ### How the plugin works
          - Intercepts fetch() calls to generativelanguage.googleapis.com
          - Transforms requests to Antigravity API format
          - Handles OAuth token exchange via Google credentials
          - Supports multi-account rotation on rate limits (429)
          - Strips Claude thinking blocks from outgoing requests (fixes signature errors)
          - Recovers interrupted tool sessions with synthetic tool_result blocks

          ### Common issues and solutions
          1. 403 Forbidden - OAuth token expired. Solution: Re-run gemini auth login
          2. 429 Too Many Requests - Rate limited. Solution: Add more accounts or wait
          3. Model not found - Model name incorrect. Check supported models in README
          4. Signature validation error - Fixed by thinking block stripping. Clear session if persists
          5. tool_result_missing - Session interrupted. Plugin auto-recovers, retry if needed
          6. antigravity.json not found - Copy config template from README
          7. Plugin not loading - Check oh-my-opencode or DCP installation

          ### Configuration files
          - antigravity.json: Main config (accounts, endpoints)
          - accounts.json: Multi-account credentials

          ## Available Labels

          ### Type labels (pick exactly one)
          - bug: Something broken (errors, crashes, unexpected behavior)
          - enhancement: Feature request or improvement
          - documentation: Docs unclear/missing/outdated
          - question: User asking for help
          - invalid: Spam or off-topic

          ### Area labels (pick exactly one)
          - area/auth: OAuth, login, tokens, credentials, 403 errors
          - area/models: Model access, Claude/Gemini specific
          - area/config: Configuration files, setup
          - area/compat: Compatibility with OpenCode, DCP

          ## Task
          1. Select ONE type label
          2. Select ONE area label  
          3. Check if this is a DUPLICATE of another open issue (check the list above!)
          4. Provide a helpful response IN ENGLISH if you can solve the issue

          ## Output (ONLY valid JSON, no markdown, no code blocks)
          {"type_label": "bug", "area_label": "area/auth", "duplicate_of": null, "suggested_response": "This looks like an expired OAuth token. Try running gemini auth login to refresh your credentials."}
          EOF

      - name: 'Triage with Jules API'
        id: 'jules_triage'
        if: steps.check_labels.outputs.skip != 'true'
        continue-on-error: true
        env:
          JULES_API_KEY: '${{ secrets.JULES_API_KEY }}'
        run: |
          PROMPT=$(cat triage_prompt.txt)
          ESCAPED_PROMPT=$(echo "$PROMPT" | jq -Rs .)
          
          RESPONSE=$(curl -s 'https://jules.googleapis.com/v1alpha/sessions' \
            -X POST \
            -H "Content-Type: application/json" \
            -H "X-Goog-Api-Key: $JULES_API_KEY" \
            -d "{
              \"prompt\": $ESCAPED_PROMPT,
              \"sourceContext\": {
                \"source\": \"sources/github/${{ github.repository }}\",
                \"githubRepoContext\": {
                  \"startingBranch\": \"main\"
                }
              },
              \"requirePlanApproval\": false
            }")
          
          echo "Jules response: $RESPONSE"
          
          SESSION_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
          if [ -z "$SESSION_ID" ]; then
            ERROR=$(echo "$RESPONSE" | jq -r '.error.message // "Unknown error"')
            echo "Jules API Error: $ERROR"
            echo "jules_success=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Session created: $SESSION_ID"
          echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT
          
          echo "Waiting for Jules to complete (max 15 minutes)..."
          for i in {1..90}; do
            sleep 10
            STATUS=$(curl -s "https://jules.googleapis.com/v1alpha/sessions/$SESSION_ID" \
              -H "X-Goog-Api-Key: $JULES_API_KEY")
            
            STATE=$(echo "$STATUS" | jq -r '.state // empty')
            echo "Attempt $i: State = $STATE"
            
            if [ "$STATE" = "COMPLETED" ] || [ "$STATE" = "FAILED" ] || [ "$STATE" = "CANCELLED" ]; then
              echo "Jules finished with state: $STATE"
              
              if [ "$STATE" = "COMPLETED" ]; then
                OUTPUT=$(echo "$STATUS" | jq -r '.outputs[0].text // empty')
                if [ -n "$OUTPUT" ]; then
                  echo "result<<EOF" >> $GITHUB_OUTPUT
                  echo "$OUTPUT" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                  echo "jules_success=true" >> $GITHUB_OUTPUT
                  exit 0
                fi
              fi
              
              echo "jules_success=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          done
          
          echo "Jules timed out"
          echo "jules_success=false" >> $GITHUB_OUTPUT

      - name: 'Fallback to Gemini 3 Flash'
        id: 'gemini_fallback'
        if: steps.check_labels.outputs.skip != 'true' && steps.jules_triage.outputs.jules_success != 'true'
        env:
          GEMINI_API_KEY: '${{ secrets.GEMINI_API_KEY }}'
        run: |
          PROMPT=$(cat triage_prompt.txt)
          ESCAPED_PROMPT=$(echo "$PROMPT" | jq -Rs .)
          
          RESPONSE=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{\"text\": $ESCAPED_PROMPT}]
              }],
              \"generationConfig\": {
                \"temperature\": 0.1,
                \"maxOutputTokens\": 1024
              }
            }")
          
          echo "Gemini response: $RESPONSE"
          
          TEXT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty')
          if [ -z "$TEXT" ]; then
            ERROR=$(echo "$RESPONSE" | jq -r '.error.message // "Unknown error"')
            echo "Gemini API Error: $ERROR"
            exit 1
          fi
          
          echo "result<<EOF" >> $GITHUB_OUTPUT
          echo "$TEXT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 'Apply Labels and Respond'
        if: steps.check_labels.outputs.skip != 'true'
        uses: 'actions/github-script@v7'
        env:
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.number }}'
          JULES_OUTPUT: '${{ steps.jules_triage.outputs.result }}'
          GEMINI_OUTPUT: '${{ steps.gemini_fallback.outputs.result }}'
        with:
          script: |
            const rawOutput = process.env.JULES_OUTPUT || process.env.GEMINI_OUTPUT;
            if (!rawOutput) {
              core.warning('No triage output available');
              return;
            }
            
            core.info(`Triage output: ${rawOutput}`);
            
            let parsed;
            try {
              parsed = JSON.parse(rawOutput.trim());
            } catch (e) {
              const match = rawOutput.match(/```(?:json)?\s*([\s\S]*?)\s*```/) || 
                           rawOutput.match(/\{[\s\S]*?\}/);
              if (match) {
                try {
                  parsed = JSON.parse(match[1] || match[0]);
                } catch (e2) {
                  core.setFailed(`Failed to parse output: ${rawOutput}`);
                  return;
                }
              } else {
                core.setFailed(`Failed to parse output: ${rawOutput}`);
                return;
              }
            }
            
            const typeLabel = parsed.type_label;
            const areaLabel = parsed.area_label;
            const duplicateOf = parsed.duplicate_of;
            const suggestedResponse = parsed.suggested_response;
            
            const validTypeLabels = ['bug', 'enhancement', 'documentation', 'question', 'invalid'];
            const validAreaLabels = ['area/auth', 'area/models', 'area/config', 'area/compat'];
            
            const labelsToAdd = [];
            const labelsToRemove = ['needs-triage'];
            
            if (typeLabel && validTypeLabels.includes(typeLabel)) {
              labelsToAdd.push(typeLabel);
            }
            if (areaLabel && validAreaLabels.includes(areaLabel)) {
              labelsToAdd.push(areaLabel);
            }
            if (duplicateOf) {
              labelsToAdd.push('duplicate');
            }
            
            if (labelsToAdd.length === 0) {
              core.warning('No valid labels found, keeping needs-triage');
              return;
            }
            
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: labelsToAdd
            });
            core.info(`Added labels: ${labelsToAdd.join(', ')}`);
            
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  name: label
                });
                core.info(`Removed label: ${label}`);
              } catch (e) {
                core.info(`Label ${label} not present, skipping removal`);
              }
            }
            
            if (suggestedResponse && suggestedResponse.trim()) {
              let body = `üëã Thanks for opening this issue!\n\n${suggestedResponse}`;
              
              if (duplicateOf) {
                body += `\n\nüîó This appears to be related to #${duplicateOf}. Please check that issue for updates.`;
              }
              
              body += `\n\n---\n*This is an automated response. A maintainer will review your issue soon.*`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: body
              });
              core.info('Posted response comment');
            }
            
            if (duplicateOf) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: 'closed',
                state_reason: 'not_planned'
              });
              core.info(`Closed as duplicate of #${duplicateOf}`);
            }

      - name: 'Comment on failure'
        if: failure()
        uses: 'actions/github-script@v7'
        env:
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.number || github.event.issue.number }}'
          RUN_URL: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
        with:
          script: |
            if (!process.env.ISSUE_NUMBER) return;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(process.env.ISSUE_NUMBER),
              body: `‚ö†Ô∏è Automated triage failed. [View logs](${process.env.RUN_URL})`
            });
